import { Hono } from 'hono'

type Bindings = {
  LINE_CHANNEL_ACCESS_TOKEN: string
  FIREBASE_PROJECT_ID: string
  RICH_MENU_MEMBER: string
  RICH_MENU_GUEST: string
  GOOGLE_AI_KEY: string 
}

const app = new Hono<{ Bindings: Bindings }>()

app.post('/', async (c) => {
  const body = await c.req.json()
  const events = body.events || []

  c.executionCtx.waitUntil(
    Promise.all(events.map((event: any) => handleEvent(event, c.env)))
  )

  return c.text('OK')
})

async function handleEvent(event: any, env: Bindings) {
  const userId = event.source.userId
  const replyToken = event.replyToken

  // ★追加: 特定ユーザーのブロック機能
  // 指定されたIDからのアクセスの場合は、警告メッセージを返して処理を終了する
  const blockedUserIds = [
    'U974d87afabfcbbd08e58e224224f0459'
    // 'Ud626706f229a30d1479043d1990ff7c5' // ブロック解除
  ]

  if (blockedUserIds.includes(userId)) {
    if (replyToken) {
      await replyText(replyToken, '作成者：児島颯太朗によりこの機能をブロックされています', env)
    }
    return
  }

  try {
    // 自動リッチメニュー更新
    if (userId) {
      await checkAndSwitchRichMenu(userId, env).catch(e => console.error('Auto Menu Update Error:', e))
    }

    if (event.type === 'follow') return

    // ------------------------------------------------
    // 1. 画像が送られてきた場合
    // ------------------------------------------------
    if (event.type === 'message' && event.message.type === 'image') {
      const userState = await getUserState(userId, env)

      if (userState?.status === 'waiting_for_cuesheet' && userState.selectedBandId) {
        // 画像保存のみ実行（解析はあとで）
        await processImageUpload(event.message.id, userState.selectedBandId, userId, replyToken, env, userState.isResubmission)
        
        await updateUserState(userId, { status: 'idle', selectedBandId: null, isResubmission: false }, env)
      }
      return
    }

    // ------------------------------------------------
    // 2. テキストメッセージ
    // ------------------------------------------------
    if (event.type === 'message' && event.message.type === 'text') {
      const text = event.message.text

      if (text === 'メニュー更新') {
        await linkRichMenu(userId, env.RICH_MENU_MEMBER, env)
        return replyText(replyToken, '✅ メニューを更新しました。', env)
      }
      
      if (text === 'Cueシート送信[]') {
        return replyMenuFlex(replyToken, env)
      }

      if (text === '提出する') {
        const bands = await getBandsForUser(userId, env)
        if (bands.length === 0) return replyErrorFlex(replyToken, env)
        return replyBandSelectionFlex(replyToken, bands, env)
      }

      if (text === 'キャンセル') {
        return replyText(replyToken, '[Bot]操作を取り消しました', env)
      }
    }

    // ------------------------------------------------
    // 3. ボタン選択時 (Postback)
    // ------------------------------------------------
    if (event.type === 'postback') {
      const data = new URLSearchParams(event.postback.data)
      const action = data.get('action')

      // バンド選択
      if (action === 'select_band') {
        const bandId = data.get('bandId')
        const bandName = data.get('bandName')
        if (!bandId) return

        const bandInfo = await getBandInfo(bandId, env)
        const isResubmission = !!bandInfo?.latestCuesheetUrl

        await updateUserState(userId, {
          status: 'waiting_for_cuesheet',
          selectedBandId: bandId,
          isResubmission: isResubmission
        }, env)

        const msg = isResubmission
          ? `${bandName} のCueシートの再送信ですね。\nCueシートを送信してください。\n(保存には数秒かかることがあります)`
          : `${bandName} のCueシートですね。\nCueシートを送信してください。\n(保存には数秒かかることがあります)`

        return replyText(replyToken, msg, env)
      }

      // AI解析の開始
      if (action === 'start_analysis') {
        await startAiAnalysis(userId, replyToken, env)
        return
      }

      // 解析結果の適用（自動入力）
      if (action === 'apply_analysis') {
        await applyAnalysisResult(userId, env)
        return replyText(replyToken, '自動入力を完了しました！', env)
      }

      // 解析結果の破棄（キャンセル）
      if (action === 'discard_analysis') {
        await clearTempAnalysis(userId, env)
        return replyText(replyToken, '[Bot]自動入力をキャンセルしました。（画像は保存されています）', env)
      }

      if (action === 'cancel') {
        await updateUserState(userId, { status: 'idle', selectedBandId: null, isResubmission: false }, env)
        return replyText(replyToken, '[Bot]操作を取り消しました', env)
      }
    }

  } catch (e) {
    console.error('Error:', e)
  }
}

// ------------------------------------------------
// メインロジック
// ------------------------------------------------

// 画像保存のみを行う（解析はしない）
async function processImageUpload(messageId: string, bandId: string, userId: string, replyToken: string, env: Bindings, isResubmission: boolean = false) {
  try {
    await showLoadingAnimation(userId, 5, env)

    // 1. 画像取得
    const blob = await getLineContent(messageId, env)
    
    // 2. アップロード
    const imageUrl = await uploadToCatbox(blob, messageId)
    if (!imageUrl) {
      await replyText(replyToken, '画像のアップロードに失敗しました。', env)
      return
    }

    // 3. Firestore保存
    const savedDocId = await saveCueSheetHistory(bandId, imageUrl, userId, env)
    await updateLatestCueSheet(bandId, imageUrl, env)

    // 解析用に直近のアップロード情報を保存しておく
    await saveLastUploadInfo(userId, { docId: savedDocId, bandId, imageUrl }, env)

    // バンド名取得
    const bandInfo = await getBandInfo(bandId, env)
    const bandName = bandInfo?.name || '不明なバンド'

    // 4. 完了Flex送信 (ここにAI解析ボタンがつく)
    await replySuccessFlex(replyToken, bandName, imageUrl, env)

  } catch (e) {
    console.error('Process Error:', e)
    await replyText(replyToken, '処理中にエラーが発生しました。', env)
  }
}

// ボタンが押されたら解析を開始する
async function startAiAnalysis(userId: string, replyToken: string, env: Bindings) {
  try {
    // 1. 直近のアップロード情報を取得
    const info = await getLastUploadInfo(userId, env)
    if (!info) {
      return replyText(replyToken, '解析対象の画像が見つかりません。画像を再送してください。', env)
    }

    await showLoadingAnimation(userId, 15, env) // 解析用に長めに表示
    console.log(`[AI Analysis] Starting... User:${userId}, Doc:${info.docId}`)

    // 2. 画像をURLから取得
    console.log(`[AI Analysis] Fetching image from: ${info.imageUrl}`)
    const imageRes = await fetch(info.imageUrl, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (compatible; LineBot/1.0)'
      }
    })
    
    if (!imageRes.ok) {
      throw new Error(`Failed to fetch image for analysis. Status: ${imageRes.status}`)
    }
    const imageBlob = await imageRes.blob()

    // 3. Geminiで解析
    console.log(`[AI Analysis] Calling Gemini API...`)
    const result = await analyzeImageWithGemini(imageBlob, env)
    
    console.log(`[AI Analysis] Result:`, JSON.stringify(result))

    // 4. 結果表示
    if (result && result.success && result.data) {
      // 解析結果を一時保存
      await saveTempAnalysis(userId, info.docId, info.bandId, result.data, env)
      
      const bandInfo = await getBandInfo(info.bandId, env)
      await replyAnalysisConfirmationFlex(replyToken, bandInfo?.name || 'バンド', info.imageUrl, result.data, env)
    } else {
      // 解析失敗時、AIからのメッセージ（生テキストやエラー内容）をそのまま返す
      const errorMessage = result?.message || '解析に失敗しました（詳細なし）。'
      await replyText(replyToken, errorMessage, env)
    }

  } catch (e) {
    console.error('[AI Analysis Error]', e)
    await replyText(replyToken, `解析中にエラーが発生しました。\n${e}`, env)
  }
}

// ------------------------------------------------
// AI解析関連 (Gemini)
// ------------------------------------------------

async function analyzeImageWithGemini(imageBlob: Blob, env: Bindings) {
  if (!env.GOOGLE_AI_KEY) {
    console.error('GOOGLE_AI_KEY is not set.')
    return { success: false, message: 'API Key is missing.' }
  }

  try {
    const arrayBuffer = await imageBlob.arrayBuffer()
    
    // 大きなファイルでもスタックオーバーフローしないBase64変換
    let binary = ''
    const bytes = new Uint8Array(arrayBuffer)
    const len = bytes.byteLength
    // 1024バイトずつ処理
    for (let i = 0; i < len; i += 1024) {
      binary += String.fromCharCode(...bytes.subarray(i, i + 1024))
    }
    const base64Image = btoa(binary)

    // ★修正: モデル名をユーザー指定の gemini-2.5-flash に変更
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${env.GOOGLE_AI_KEY}`
    
    const prompt = `
      この画像はバンドのCueシート(セットリストや進行表)です。
      以下の情報をJSON形式で抽出してください。
      項目が見つからない場合は空配列またはfalseにしてください。
      JSON以外の説明文は不要です。

      【同期演奏(has_backing_track)の判定について】
      画像内の「同期」または「同期音源」の欄を確認してください。
      「有」と「無」の選択肢があり、「有」の方に丸（○）がついている場合のみ true としてください。
      「無」に丸がついている場合、またはどちらにも丸がない場合は false としてください。
      
      出力フォーマット:
      {
        "songs": [
          {"title": "曲名", "duration": "分:秒"},
          ...
        ],
        "ng_dates": [
          {"date": "月/日", "time": "HH:MM-HH:MM"},
          ...
        ],
        "has_backing_track": true/false
      }
    `

    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{
          parts: [
            { text: prompt },
            { inlineData: { mimeType: "image/jpeg", data: base64Image } }
          ]
        }],
        generationConfig: { responseMimeType: "application/json" }
      })
    })

    if (!response.ok) {
      const txt = await response.text()
      console.error(`Gemini API Error: ${response.status} ${txt}`)
      return { success: false, message: `Gemini API Error: ${response.status}\n${txt}` }
    }

    const result = await response.json() as any
    let jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text
    if (!jsonText) return { success: false, message: 'Gemini returned empty text.' }

    const rawText = jsonText; // 生のテキストを保存

    // Markdown記法 (```json ... ```) が含まれていたら削除する
    jsonText = jsonText.replace(/```json/g, '').replace(/```/g, '').trim()

    try {
      const data = JSON.parse(jsonText)
      return { success: true, data: data }
    } catch (e) {
      // JSONパースエラー時は生のテキストを返す
      return { success: false, message: `解析結果の読み取りに失敗しました。\n\n▼AIからの返信:\n${rawText}` }
    }

  } catch (e) {
    console.error('Analysis Logic Error:', e)
    return { success: false, message: `Analysis Logic Error: ${e}` }
  }
}

// 直近のアップロード情報を保存
async function saveLastUploadInfo(userId: string, info: any, env: Bindings) {
  const url = `${fsUrl(env)}/users/${userId}?updateMask.fieldPaths=lastUpload`
  await fetch(url, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      fields: {
        lastUpload: {
          mapValue: {
            fields: {
              docId: { stringValue: info.docId },
              bandId: { stringValue: info.bandId },
              imageUrl: { stringValue: info.imageUrl }
            }
          }
        }
      }
    })
  })
}

// 直近のアップロード情報を取得
async function getLastUploadInfo(userId: string, env: Bindings) {
  const res = await fetch(`${fsUrl(env)}/users/${userId}`)
  
  if (!res.ok) {
    console.error(`getLastUploadInfo failed: ${res.status} ${await res.text()}`)
    return null
  }

  const json: any = await res.json()
  const fields = json.fields?.lastUpload?.mapValue?.fields
  if (!fields) return null
  return {
    docId: fields.docId.stringValue,
    bandId: fields.bandId.stringValue,
    imageUrl: fields.imageUrl.stringValue
  }
}

// 解析結果の一時保存
async function saveTempAnalysis(userId: string, docId: string, bandId: string, data: any, env: Bindings) {
  const url = `${fsUrl(env)}/users/${userId}?updateMask.fieldPaths=tempAnalysis`
  await fetch(url, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      fields: {
        tempAnalysis: {
          mapValue: {
            fields: {
              docId: { stringValue: docId },
              bandId: { stringValue: bandId },
              rawData: { stringValue: JSON.stringify(data) }
            }
          }
        }
      }
    })
  })
}

// 解析結果の適用 (Commitを使って一括処理)
async function applyAnalysisResult(userId: string, env: Bindings) {
  const userRes = await fetch(`${fsUrl(env)}/users/${userId}`)
  const userJson: any = await userRes.json()
  const temp = userJson.fields?.tempAnalysis?.mapValue?.fields
  
  if (!temp) return

  const docId = temp.docId.stringValue
  const bandId = temp.bandId.stringValue
  const rawData = JSON.parse(temp.rawData.stringValue)

  // 1. バンド情報を取得して既存の曲リストを得る
  const bandRes = await fetch(`${fsUrl(env)}/bands/${bandId}`);
  const bandJson: any = await bandRes.json();
  const currentSongs = bandJson.fields?.songs?.arrayValue?.values || [];

  // 既存の曲タイトルをSetにしておく（重複チェック用）
  const existingTitles = new Set(currentSongs.map((s: any) => s.mapValue.fields.title.stringValue));

  // 2. 解析結果から新規曲のみを抽出してID付与
  const newSongs = [];
  for (const song of (rawData.songs || [])) {
    const title = song.title || "";
    // タイトルがあり、かつ既存リストに存在しない場合のみ追加
    if (title && !existingTitles.has(title)) {
      newSongs.push({
        mapValue: {
          fields: {
            id: { stringValue: generateRandomId(15) },
            title: { stringValue: title },
            duration: { stringValue: song.duration || "" }
          }
        }
      });
      existingTitles.add(title); // 解析結果内での重複も防ぐ
    }
  }

  // 3. 更新用の曲リストを作成（既存 + 新規）
  const updatedSongsList = [...currentSongs, ...newSongs];

  const commitUrl = `https://firestore.googleapis.com/v1/projects/${env.FIREBASE_PROJECT_ID}/databases/(default)/documents:commit`
  
  const writes = [];

  // Write 1: Cueシートに解析結果を追記 (analysisフィールド)
  writes.push({
    update: {
      name: `projects/${env.FIREBASE_PROJECT_ID}/databases/(default)/documents/bands/${bandId}/cuesheets/${docId}`,
      fields: {
        analysis: {
          mapValue: {
            fields: {
              songs: { stringValue: JSON.stringify(rawData.songs) },
              ng_dates: { stringValue: JSON.stringify(rawData.ng_dates) },
              has_backing_track: { booleanValue: !!rawData.has_backing_track }
            }
          }
        }
      }
    },
    updateMask: { fieldPaths: ["analysis"] }
  });

  // Write 2: バンドの曲リストを更新 (差分があった場合のみ)
  if (newSongs.length > 0) {
    writes.push({
      update: {
        name: `projects/${env.FIREBASE_PROJECT_ID}/databases/(default)/documents/bands/${bandId}`,
        fields: {
            songs: {
                arrayValue: { values: updatedSongsList }
            }
        }
      },
      updateMask: { fieldPaths: ["songs"] }
    });
  }

  // Write 3: 一時データ削除 (tempAnalysisフィールドを削除)
  writes.push({
    update: {
      name: `projects/${env.FIREBASE_PROJECT_ID}/databases/(default)/documents/users/${userId}`,
      fields: {} // 空オブジェクト
    },
    updateMask: { fieldPaths: ["tempAnalysis"] }
  });

  // 一括実行
  const res = await fetch(commitUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ writes })
  });

  if (!res.ok) {
    console.error("Apply Analysis Commit failed", await res.text());
  }
}

async function clearTempAnalysis(userId: string, env: Bindings) {
  const url = `${fsUrl(env)}/users/${userId}?updateMask.fieldPaths=tempAnalysis`
  await fetch(url, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      fields: {
        tempAnalysis: { nullValue: null }
      }
    })
  })
}

// ------------------------------------------------
// Flex Message
// ------------------------------------------------

async function replyAnalysisConfirmationFlex(token: string, bandName: string, imageUrl: string, data: any, env: Bindings) {
  const songRows = (data.songs || []).map((song: any) => ({
    "type": "box",
    "layout": "horizontal",
    "contents": [
      {
        "type": "text",
        "text": song.title || "不明な曲",
        "size": "sm",
        "color": "#555555",
        "flex": 0
      },
      {
        "type": "text",
        "text": song.duration || "--:--",
        "size": "sm",
        "color": "#111111",
        "align": "end"
      }
    ]
  }));

  const ngRows = (data.ng_dates || []).map((ng: any) => ({
    "type": "box",
    "layout": "horizontal",
    "contents": [
      {
        "type": "text",
        "text": ng.date || "日付不明",
        "size": "sm",
        "color": "#555555"
      },
      {
        "type": "text",
        "text": ng.time || "時間不明",
        "size": "sm",
        "color": "#111111",
        "align": "end"
      }
    ]
  }));

  const hasBackingTrackText = data.has_backing_track ? "あり" : "なし";

  const flexContent = {
    "type": "bubble",
    "body": {
      "type": "box",
      "layout": "vertical",
      "contents": [
        {
          "type": "text",
          "text": "自動入力補助(β)",
          "weight": "bold",
          "color": "#fabf66",
          "size": "sm"
        },
        {
          "type": "text",
          "text": bandName,
          "weight": "bold",
          "size": "xxl",
          "margin": "md"
        },
        {
          "type": "text",
          "text": "曲やNG日を自動入力します",
          "size": "xs",
          "color": "#aaaaaa",
          "wrap": true
        },
        {
          "type": "separator",
          "margin": "xxl"
        },
        {
          "type": "box",
          "layout": "vertical",
          "margin": "xxl",
          "spacing": "sm",
          "contents": [
            {
              "type": "text",
              "text": "曲情報",
              "size": "lg",
              "weight": "bold"
            },
            ...songRows,
            {
              "type": "separator",
              "margin": "xxl"
            },
            {
              "type": "text",
              "text": "出演NG日",
              "margin": "xxl",
              "weight": "bold"
            },
            ...ngRows,
            {
              "type": "separator",
              "margin": "xxl"
            },
            {
              "type": "box",
              "layout": "horizontal",
              "contents": [
                {
                  "type": "text",
                  "text": "同期演奏",
                  "size": "sm",
                  "color": "#555555"
                },
                {
                  "type": "text",
                  "text": hasBackingTrackText,
                  "size": "sm",
                  "color": "#111111",
                  "align": "end"
                }
              ]
            }
          ]
        },
        {
          "type": "separator",
          "margin": "xxl"
        },
        {
          "type": "box",
          "layout": "horizontal",
          "margin": "md",
          "contents": [
            {
              "type": "text",
              "text": "この解析はβ版です",
              "size": "xs",
              "color": "#aaaaaa",
              "flex": 0
            }
          ]
        },
        {
          "type": "button",
          "action": {
            "type": "postback",
            "label": "正しいので自動入力する",
            "data": "action=apply_analysis"
          },
          "color": "#4287f5"
        },
        {
          "type": "button",
          "action": {
            "type": "postback",
            "label": "間違っているのでキャンセル",
            "data": "action=discard_analysis"
          },
          "color": "#f54278"
        }
      ]
    },
    "styles": {
      "footer": {
        "separator": true
      }
    }
  }

  await replyFlex(token, '解析結果を確認してください', flexContent, env)
}

// ------------------------------------------------
// 既存ヘルパー関数
// ------------------------------------------------

async function saveCueSheetHistory(bandId: string, imageUrl: string, userId: string, env: Bindings): Promise<string> {
  const url = `${fsUrl(env)}/bands/${bandId}/cuesheets`
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      fields: {
        url: { stringValue: imageUrl },
        uploadedBy: { stringValue: userId },
        createdAt: { timestampValue: new Date().toISOString() }
      }
    })
  })
  if (!res.ok) throw new Error(`History Save Failed: ${res.status}`)
  
  const json: any = await res.json()
  const docPath = json.name
  return docPath.split('/').pop()
}

async function showLoadingAnimation(chatId: string, seconds: number, env: Bindings) {
  try {
    await fetch('https://api.line.me/v2/bot/chat/loading/start', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${env.LINE_CHANNEL_ACCESS_TOKEN}`
      },
      body: JSON.stringify({ chatId: chatId, loadingSeconds: seconds })
    })
  } catch (e) { console.error(e) }
}

async function checkAndSwitchRichMenu(userId: string, env: Bindings): Promise<boolean> {
  await linkRichMenu(userId, env.RICH_MENU_MEMBER, env)
  return true
}

async function linkRichMenu(userId: string, richMenuId: string, env: Bindings) {
  if (!richMenuId) return
  try {
    await fetch(`https://api.line.me/v2/bot/user/${userId}/richmenu/${richMenuId}`, {
      method: 'POST',
      headers: { Authorization: `Bearer ${env.LINE_CHANNEL_ACCESS_TOKEN}` }
    })
  } catch (e) { console.error(`RichMenu Link Error: ${e}`) }
}

async function updateLatestCueSheet(bandId: string, imageUrl: string, env: Bindings) {
  const url = `${fsUrl(env)}/bands/${bandId}?updateMask.fieldPaths=latestCuesheetUrl`
  const res = await fetch(url, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      fields: { latestCuesheetUrl: { stringValue: imageUrl } }
    })
  })
  if (!res.ok) throw new Error(`Latest Update Failed: ${res.status}`)
}

async function uploadToCatbox(blob: Blob, filename: string): Promise<string | null> {
  const formData = new FormData()
  formData.append('reqtype', 'fileupload')
  formData.append('fileToUpload', blob, `${filename}.jpg`)

  try {
    const res = await fetch('https://catbox.moe/user/api.php', {
      method: 'POST',
      body: formData,
      headers: { 'User-Agent': 'Mozilla/5.0 (compatible; LineBot/1.0)' }
    })
    if (!res.ok) return null
    const url = await res.text()
    if (url.startsWith('http')) return url.trim()
    return null
  } catch (e) { return null }
}

const fsUrl = (env: Bindings) => `https://firestore.googleapis.com/v1/projects/${env.FIREBASE_PROJECT_ID}/databases/(default)/documents`

async function getBandsForUser(userId: string, env: Bindings) {
  const query = {
    structuredQuery: {
      from: [{ collectionId: 'bands' }],
      where: {
        fieldFilter: {
          field: { fieldPath: 'memberIds' },
          op: 'ARRAY_CONTAINS',
          value: { stringValue: userId }
        }
      }
    }
  }
  const res = await fetch(`${fsUrl(env)}:runQuery`, { method: 'POST', body: JSON.stringify(query) })
  const json: any = await res.json()
  if (!json || !Array.isArray(json)) return []
  
  return json
    .filter((item: any) => item.document)
    .map((item: any) => {
      const doc = item.document
      return { 
        id: doc.name.split('/').pop(), 
        name: doc.fields.name?.stringValue || '名称未設定',
        iconUrl: doc.fields.icon?.stringValue,
        isArchived: doc.fields.isArchived?.booleanValue || false
      }
    })
    .filter((band: any) => !band.isArchived)
}

async function getBandInfo(bandId: string, env: Bindings) {
  const res = await fetch(`${fsUrl(env)}/bands/${bandId}`)
  if (!res.ok) return null
  const json: any = await res.json()
  return {
    name: json.fields?.name?.stringValue,
    latestCuesheetUrl: json.fields?.latestCuesheetUrl?.stringValue
  }
}

async function updateUserState(userId: string, data: any, env: Bindings) {
  const url = `${fsUrl(env)}/users/${userId}?updateMask.fieldPaths=status&updateMask.fieldPaths=selectedBandId&updateMask.fieldPaths=isResubmission`
  await fetch(url, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      fields: {
        status: { stringValue: data.status },
        selectedBandId: { [data.selectedBandId ? 'stringValue' : 'nullValue']: data.selectedBandId },
        isResubmission: { booleanValue: !!data.isResubmission }
      }
    })
  })
}

async function getUserState(userId: string, env: Bindings) {
  const res = await fetch(`${fsUrl(env)}/users/${userId}`)
  if (!res.ok) return null
  const json: any = await res.json()
  return {
    status: json.fields?.status?.stringValue,
    selectedBandId: json.fields?.selectedBandId?.stringValue,
    isResubmission: json.fields?.isResubmission?.booleanValue
  }
}

async function getLineContent(messageId: string, env: Bindings) {
  const res = await fetch(`https://api-data.line.me/v2/bot/message/${messageId}/content`, {
    headers: { Authorization: `Bearer ${env.LINE_CHANNEL_ACCESS_TOKEN}` }
  })
  return await res.blob()
}

async function replyText(token: string, text: string, env: Bindings) {
  await fetch('https://api.line.me/v2/bot/message/reply', {
    method: 'POST',
    headers: { 
      'Content-Type': 'application/json',
      Authorization: `Bearer ${env.LINE_CHANNEL_ACCESS_TOKEN}`
    },
    body: JSON.stringify({
      replyToken: token,
      messages: [{ type: 'text', text: text }]
    })
  })
}

async function replyBandSelectionFlex(token: string, bands: any[], env: Bindings) {
  const bubbles = bands.map((band: any) => ({
    "type": "bubble",
    "size": "micro",
    "hero": {
      "type": "image",
      "url": band.iconUrl || "https://developers-resource.landpress.line.me/fx/clip/clip13.jpg",
      "size": "full",
      "aspectMode": "cover",
      "aspectRatio": "320:213"
    },
    "body": {
      "type": "box",
      "layout": "vertical",
      "contents": [
        {
          "type": "text",
          "text": band.name || "名称未設定",
          "weight": "bold",
          "size": "sm",
          "wrap": true,
          "gravity": "center",
          "align": "center"
        },
        {
          "type": "box",
          "layout": "vertical",
          "contents": [
            {
              "type": "box",
              "layout": "baseline",
              "spacing": "sm",
              "contents": []
            },
            {
              "type": "button",
              "action": {
                "type": "postback",
                "label": "選択",
                "data": `action=select_band&bandId=${band.id}&bandName=${band.name || 'このバンド'}`
              },
              "gravity": "top"
            }
          ]
        }
      ],
      "spacing": "sm",
      "paddingAll": "13px"
    }
  }))

  const carouselContent = {
    "type": "carousel",
    "contents": bubbles
  }

  await replyFlex(token, 'バンドを選択してください', carouselContent, env)
}

async function replyMenuFlex(token: string, env: Bindings) {
  const flexContent = {
    "type": "bubble",
    "body": {
      "type": "box",
      "layout": "vertical",
      "contents": [
        {
          "type": "text",
          "text": "Cueシートメニュー",
          "weight": "bold",
          "size": "xl"
        },
        {
          "type": "box",
          "layout": "vertical",
          "margin": "lg",
          "spacing": "sm",
          "contents": [
            {
              "type": "box",
              "layout": "baseline",
              "spacing": "sm",
              "contents": [
                {
                  "type": "text",
                  "text": "どの操作をしますか？",
                  "wrap": true,
                  "color": "#666666",
                  "size": "sm",
                  "flex": 5
                }
              ]
            }
          ]
        }
      ]
    },
    "footer": {
      "type": "box",
      "layout": "vertical",
      "spacing": "sm",
      "contents": [
        {
          "type": "button",
          "style": "link",
          "height": "sm",
          "action": {
            "type": "message",
            "label": "Cueシートを提出/再提出する",
            "text": "提出する"
          }
        },
        {
          "type": "button",
          "style": "link",
          "height": "sm",
          "action": {
            "type": "message",
            "label": "キャンセル",
            "text": "キャンセル"
          }
        },
        {
          "type": "box",
          "layout": "vertical",
          "contents": [],
          "margin": "sm"
        }
      ],
      "flex": 0
    }
  }

  await replyFlex(token, 'Cueシートメニュー', flexContent, env)
}

async function replyErrorFlex(token: string, env: Bindings) {
  const flexContent = {
    "type": "bubble",
    "body": {
      "type": "box",
      "layout": "vertical",
      "contents": [
        {
          "type": "text",
          "text": "システムエラー",
          "weight": "bold",
          "size": "lg"
        },
        {
          "type": "box",
          "layout": "vertical",
          "margin": "lg",
          "spacing": "sm",
          "contents": [
            {
              "type": "box",
              "layout": "baseline",
              "spacing": "sm",
              "contents": [
                {
                  "type": "text",
                  "text": "参加しているバンドを認識できませんでした[Error:404]",
                  "wrap": true,
                  "color": "#666666",
                  "size": "sm",
                  "flex": 5
                }
              ]
            },
            {
              "type": "box",
              "layout": "baseline",
              "spacing": "sm",
              "contents": [
                {
                  "type": "text",
                  "text": "マイバンドタブまたは以下からバンドを新規作成してください",
                  "wrap": true,
                  "color": "#666666",
                  "size": "sm",
                  "flex": 5
                }
              ]
            }
          ]
        }
      ]
    },
    "footer": {
      "type": "box",
      "layout": "vertical",
      "spacing": "sm",
      "contents": [
        {
          "type": "button",
          "style": "link",
          "height": "sm",
          "action": {
            "type": "uri",
            "label": "新規バンドを作成",
            "uri": "https://liff.line.me/2008162165-vVODNp12"
          }
        },
        {
          "type": "box",
          "layout": "vertical",
          "contents": [],
          "margin": "sm"
        },
        {
          "type": "button",
          "action": {
            "type": "uri",
            "label": "新規バンドの作成方法",
            "uri": "https://www.sorairosystem.com/urakata/lmc/how-to--use-LMCapp"
          },
          "height": "sm",
          "style": "link"
        }
      ],
      "flex": 0
    }
  }

  await replyFlex(token, 'システムエラー', flexContent, env)
}

// エラー時のためのreplyQuickReplyも残す
async function replyQuickReply(token: string, text: string, items: any[], env: Bindings) {
  await fetch('https://api.line.me/v2/bot/message/reply', {
    method: 'POST',
    headers: { 
      'Content-Type': 'application/json',
      Authorization: `Bearer ${env.LINE_CHANNEL_ACCESS_TOKEN}`
    },
    body: JSON.stringify({
      replyToken: token,
      messages: [{
        type: 'text',
        text: text,
        quickReply: { items: items }
      }]
    })
  })
}

// ランダムID生成
function generateRandomId(length: number = 15): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

export default app
